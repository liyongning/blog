# 数组

## 二分查找

* 一定是没有重复元素的有序数组，或者可以变成没有重复元素的有序数组

* 区间问题：[left, right] 和 [left, right]

  * ```javascript
    // [left, right]
    function search(nums, target, left, right) {
      while(left <= right) {
        const middle = left + ((right - left) / 2)
        if (nums[middle] > target) {
          search(nums, target, left, middle - 1)
        }
        // ...
      }
    }
    
    // [left, right)
    function search(nums, target, left, right) {
      while(left < right) {
        const middle = left + ((right - left) / 2)
        if (nums[middle] > target) {
          // 由于 right 是开区间，所以下标为 right 的元素是不算的，如果 right = middle - 1，会漏掉一个元素
          search(nums, target, left, middle)
        }
        // ...
      }
    }
    ```

* 取中间值：`left + ((right - left) / 2)`，防止下标移除，参考下图进行演算和理解

  * |------------left-------------right|



## 移除元素

* 暴力接发 —— 双循环遍历，外层循环找到指定元素，内层循环将当前位置后面的元素往前移动，进行元素覆盖

  * 时间复杂度 O(n^2)
  * 空间负责度 O(1)

* 快慢指针，通过双指针来模拟双循环，快指针充当外层循环负责寻找指定元素，慢指针充当内存循环，如果快指针每一次移动指向的元素不是目标元素，则快慢指针移动往后移动，否则只移动快指针

  * 重要代码

    * ```javascript
      if (nums[fastIndex] !== target) {
        // 完成了元素覆盖
        nums[slowIndex++] = nums[fastIndex]
      }
      // 最后 slowIndex + 1 就是新的数组长度
      ```

  * 时间复杂度 O(n)

  * 空间复杂度 O(1)

  ## 有序数组的平方

[-4,-1,0,3,10] => [16,1,0,9,100] => [0,1,9,16,100]

* 题目分析：对一个有序数据的每个元素做平方运算，需要让结果数组仍然是有序的（负数平方之后变正数，数组就不是有序的了）
* 方案：
  * 暴力解法，第一个循环遍历数组，依次对元素进行平方，然后再对平方后的数组进行排序
    * 空间复杂度 O(n)
    * 时间复杂度 O(n + nlogn)
  * 双指针，因为数组是有序的，所以平方后的最大值一定在两侧，而不是中间
    * 头指针指向数组开始位置，尾指针指向数组结束位置，每次循环移动其中一个指针，具体移动哪个取决于哪个数据平方后的结果更大
    * 额外创建一个数组，大小和原数组一致，每次都更新上一指针元素平方后更大的值所在的位置

## 长度最小的子数组

在给定数组中找到和大于等于给定值的最小连续元素，并返回元素个数

* 暴力解法，双循环，外层循环控制开始位置，内层循环从当前位置开始向后遍历元素，知道元素之和 >= 目标值，然后记录元素个数，如果在寻找过程中发现本次查找的元素个数已经大于之前的个数了，则直接结束本次查找，因为要求最小连续元素的个数
  * 空间复杂度 O(1)
  * 时间复杂度 O(n^2)
* 双指针（滑动窗口），通过双指针来模拟双循环，在两个指针之间形成一个从前向后滑动的窗口，在滑动期间窗口大小不断在变大、变小。如果当前窗口内元素之和小雨目标值，则向后移动尾指针（扩大窗口），当窗口内的元素之和 >= 目标值，开始移动头指针，直到窗口内元素之和 < 目标值，此时窗口大小 + 1 就是当前符合要求的元素个数，接着再开始移动尾指针，直到尾指针移动到结束位置并且窗口内元素之和 < 目标值，遍历结束
  * 空间复杂度 O(1)
  * 时间复杂度 O(n) => O(2n)

**滑动窗口** 的精髓之处就在于交替移动头尾指针（在从前到后移动窗口的过程中不断改变窗口大小），在不断满足目标的过程中寻找最优解

# 链表

* 单向链表、双向链表、循环链表
* 非连续存储（数据为连续存储），节点和节点之间通过 next 指针来关联
* 和数组的性能对比![img](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404181910896.png)
* 常用操作技巧
  * 设置虚拟节点来操作链表，比如移除链表元素，如果直接使用原链表操作，移除头节点时需要额外编写针对头节点的逻辑
  * 针对链表的增删改查操作，比如设计链表
  * 反转链表
    * 方案一：借助虚拟节点 + cur、pre 双指针来完成
    * 方案二：递归
  * 两两交换链表中的节点，提示：需要用到虚拟节点 + 画图（方便理解指针的移动和指向的变化）
    * ![24.两两交换链表中的节点1](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404081107586.png)
    * ![24.两两交换链表中的节点2](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404181910348.png)
    * ![24.两两交换链表中的节点3](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404081107256.png)
  * 删除链表中的倒数第 N 个节点，经典的双指针（快慢指针）应用，快指针先走 N 步，然后慢指针和快指针一起走，这样两个指针之间就形成了 N 个节点的间隔，当快指针走到链表结束后，慢指针所在的节点就是倒数第 N 个节点（这里可能会存在细节问题，实际编码的时候再修正）
  * 链表相交，双指针思路，不过这里不是快慢指针，而是用两个指针，分别走一遍两个链表，如果链表存在相交，则一定会出现 NodeA === NodeB 的情况，因为两个指针最终走的路是一样长的，如果直到两条链表都走完了，跳出了循环（null === null），则可以认为没有相交，循环的条件是 两个指针不相等
  * 环形链表，双指针解法，一个快指针一个慢指针，一旦有指针走到了结束，则说明没有环，否则一定会找到一个不为 null 的相同节点
  * 环形链表 II，双指针解法 + 数学运算，将链表分成多段，最终一定是 2(x + y) = x +(y + z) * n，最终会发现 x === z，所以就会发现两个指针分别从头和相遇点出发，再次相遇，就是入环点
    * ![img](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404181910783.png)

# 哈希表

* 数组就是最简单的哈希表，我们可以将一些字符映射到数组下标上，比如 26个英文字母可以在数组中找到一一存放的位置。以数组作为哈希表一般都会明确限制元素个数，如果元素个数太多或者太过稀疏，则会造成空间浪费
* 哈希表最关键的设计就是哈希函数，通过哈希函数将字符映射到索引上，但经常会碰到哈希碰撞的问题，即多个字符经过哈希运算之后会映射到同一个 key 上，一般有如下两种解决方案
  * 拉链法，主要是结合链表来实现，相同 key 的 value 会通过链表来连接
  * 线性探测法，结合数组实现，如果出现 key 冲突，则 value 依次往后排
* 哈希表属于空间换时间的一种数据结构，空间复杂度 O(n)，时间复杂度 O(1)，所以需要查询或者判断元素是否存在时，可以优先考虑哈希表

这里可以深入研究的是各个语言中哈希结构的底层实现，可能会用到哈希表或红黑树，哈希结构的特点或限制就和底层的数据结构有关

## 有效的字母异位词

* 两个字符串长度必然相等
* 字符串中的字符必须一样，只是顺序不一样

借助哈希表，将 26个字符映射到数组中，依次遍历两个字符串，第一个填充，第二个删除，最后数组中元素都为 0，则说明是异位词

## 两个数组的交集

可以使用哈希表 + 加集合来完成，将其中一个数组转换成哈希表，然后遍历另外一个数组，如果发现当前元素已经在哈希表中了，说明是一个交集元素，然后将结果放到集合中，集合主要是用来做元素去重的。

## 快乐数

将给定整数的每个位置上的数字平方然后求和，循环往复，如果中间出现和重复的情况，则表示这个整数不是快乐树，如果最终得到和位 1 的情况，则认为该整数是快乐数。这里关键的有以下两点：

* 判断和是否重复，需要用到哈希表，比如集合
* 计算一个整数每一位上的数字，比如 19 => 1 和 9 => 1* 1 + 9 * 9 => 82 => 8 和 2 => ...
  * 计算可以将数字专字符串然后遍历每一位
  * 也可以通过取于 + 整除得到每一位的数字

## 两数之和

关键思路：哈希表 + 查询哈希表中是否存在 target - currentEl 的值，如果存在则直接返回结果，如果不存在则将当前元素放入哈希表，key 位元素，value 为元素在数组中的下标

## N 数之和

以后补充，当前教程的思路不是很好

## 四数相加 II

给定四个数组，然后从四个数组中各取一个元素，看有多少组和为 0 的元素，主要用到了哈希表，思路如下：

* 设置一个哈希表，用来记录 A数组 + B 数组的和，和 C 数组 + D 数组元素的和，key 为和，value 这样的和出现的次数
* 通过双循环遍历 A 和 B 数组，计算两两元素之和，并将数据填充进哈希表
* 然后通过另一个双循环，计算 C 和 D 数组中两两元素之和（F），如果发现 0 - F 在哈希表中存在，则记录 map[0 - F] 的值，否则将 F 也存入哈希表
* 最终返回命令中的记录值即可

# N 数之和

没看

# 字符串

## 双指针学会了

## KMP 算法——没理解

实现 strStr() 函数

重复的子字符串

# 栈与队列

## 用栈实现队列

* 队列，先进先出
* 栈，先进后出

需要通过两个栈来模拟队列，一个入栈，一个出栈

* 入栈，入队操作时，将每次进来的数据都放到入栈中
* 出栈，出队操作时，将出栈中的数据弹出一个
  * 如果出队时，出栈为空，则将当前入栈中的数据依次写入出栈中
  * 会发现，入栈的数据到出栈中后，原本栈底的数据就到了栈顶，这时候就通过出栈实现了队列的先进先出能力
  * 当入栈和出栈都为空时，则表示队列为空

## 用队列实现栈

用一个队列来实现即可，将队头的数据循环写入对尾，原本队尾的数据最终会到对头，这时候将其出队，就实现了栈**后进先出**的效果

## 有效括号

用栈来实现就可以，栈中的内容是期望出现的内容，比如遇到了左括号，即将右括号入栈，如果栈顶的内容是右括号，意思是接下来一定要能匹配到正确类型的右括号

## 删除字符串中所有相邻的重复项

abbaca => ca

用栈来实现，首字符入栈，然后遍历字符串，如果当前字符和栈顶元素相同，则出栈，否则入栈，当字符串遍历完后，栈内剩下的字符就是没有相邻重复项的字符串

## 逆波兰表达式

["2", "1", "+", "3", " * "]

逆波兰表达式是后缀表达式，即运算符写在后面，我们平时用的是中缀表达式（但对计算机很不友好）。

逆波兰表达式非常方便通过栈来计算，数字入栈，遇到运算符，从栈顶出栈两个数字，完成计算后将结果入栈

## 滑动窗口最大值

![239.滑动窗口最大值-2](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404191115338.gif)

需要借助**单调队列**来实现，单调队列只是队列中的数据是有序的。这里我们构造一个单调递减的队列，即队头数据最大

* 初始化队列，将当前窗口中的数据在队列中排好序
  * 从前往后遍历窗口内的数据
  * 如果当前插入的数据大于队头数据，则将队列中的数据全部出队
  * 当前窗口遍历结束后，队头数据就是当前窗口的最大值
* 移动窗口
  * 移动过程中，如果发现当前元素大于队头数据，则将队列中数据清空，当前数据入队，并记为当前窗口最大值，然后继续往后移动
  * 知道窗口移动到末尾

可以发现，每次新的最大值入队的时候，会清空当前队列，这是整个思路的关键。

## 前 K 个高频元素

实用优先级队列来解决，优先级队列底层其实是堆，为什么叫队列，是因为堆的表现和队列一样，有唯一的出口和入口。

堆是一个完全二叉树，即每个节点都小于等于其子节点或大于等于其子节点，所以前者称为小顶堆，后者称为大顶堆。

本题使用小顶堆来完成，因为每次插入新的元素，如果大于堆顶的数据，则会将堆顶移除，当前插入的元素入堆，并放到合适位置，所以最终堆中的元素就是我们要的前 K 大的元素。

# 二叉树

满二叉树：一棵树只有度为 0 的节点和度为 2 的节点，并且度为 0 的节点都在同一层。节点总数为 2^h - 1，h 为树的深度（从 1 开始）。

![img](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202406110738743.png)

完全二叉树：除了最底层的节点可能没填满之外，其余每层节点都是满的，并且最底层的节点全都集中在左侧。每层的节点数为 1～2^(h - 1)，h 从 1 开始。

![img](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202406110738810.png)

二叉搜索树：是一个有序树，左子节点的值一定小于它的根节点的值，右子节点的值一定大于它的根节点的值，并且左右子树也是一个二叉搜索树。

![img](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202406110738557.png)

平衡二叉搜索树：在二叉搜索树的基础上，它是一棵空树或者左右子树的高度差不超过 1

![img](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202406110739266.png)

二叉树的存储方式：链式存储和顺序存储（数组），顺序存储时，如果父节点的下标为 i（从 0 开始），左子节点的下标为 i * 2 + 1，右子节点的下标为 i * 2 + 2。

![img](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202406110739846.png)

![img](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202406110739614.png)

遍历：遍历分为广度优先和深度优先，在二叉树中广度优先的方式为层序遍历，而深度优先的方式又称为递归遍历，分为前、中、后序遍历三种方式。

递归框架，以树遍历为例：

* 确定递归函数的入参和返回值。当前遍历的节点和存储节点值的数组
* 确定递归函数的终止条件。当前节点为空
* 确定每一层的处理逻辑。按照前、中、后续来遍历当前节点和左右子节点。

![img](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202406110739749.png)

二叉树迭代遍历：

* 前序，两个重点
  * 中节点在循环之前先入栈
  * 右节点先于左节点入栈（出栈后就变成了左 -> 右的顺序了）
* 中序，左中右，需要左侧节点一直入栈，直到当前节点为空，则开始出栈，出栈的节点如果存在右节点，则右节点入栈。
  * 整个循环中，当前节点不为空，则入栈，很关键
  * 第二点就是，当前节点出栈处理后，右侧节点入栈，这样才有机会在当前节点（中节点）处理完之后处理右节点
* 后序，左右中，调整前序的遍历顺序，即可得到结果。前序现在的入栈顺序是：中 -> 右 -> 左，做如下改造
  * 入栈顺序调整为，中 -> 左 -> 右，得到结果为 => 中 -> 右 -> 左的遍历顺序
  * 反转结果数组，得到左 -> 右 -> 中的结果

二叉树层序遍历，即广度优先，需要用队列来实现

* 根节点先入队，然后一直出队，直到队列为空
* 出队的节点，如果存在子节点，则子节点的入队顺序为先左后右

翻转二叉树，遍历每个节点（哪种遍历方式都可以），然后反转每个节点的左右子树即可

对称二叉树，左子树是由右子树翻转而来。需采用后序遍历（左右中）的方式，遍历每一个节点的左右子节点，如果每个节点的左右子节点都对称，那这个树就对称。

![101. 对称二叉树](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202406120725809.png)

二叉树最大深度 / 高度

* 深度是某个节点距离根节点的距离，根节点的深度为 1。一般用前序遍历来计算
* 高度是指某个节点距离叶子节点的距离，叶子节点高度为 1。一般用后序遍历来算
* 题目可使用后序遍历的方式（因为根节点的高度和深度是同一个值），得到二叉树的最大深度，即通过子节点的最大深度 + 1 的到父节点的深度

二叉树最小深度，思路类似，但需要注意的是叶子节点的概念：节点的左右子树都为空，才称为叶子节点。假如一个节点的左子树为空，那该节点的最小深度一定是 1 + 右子树的最小深度，不能是 1 + 0（左子树深度）。

二叉树节点数

* 普通二叉树，可使用遍历的方式，推荐后序遍历和层序遍历
* 满二叉树，2 ^ 树深度 - 1 个节点，所以重点是得到树的深度
* 完全二叉树，则介于普通和满二叉树之间

判断一棵树是否为平衡二叉树，根据定义，就是在求任意节点的高度，采用后序遍历。

二叉树的所有路径：递归 + 回溯，递归到每个叶子节点，在递归的过程中记录经过的路径，到叶子节点后存储当前路径，然后回溯，回溯是将当前节点从已记录的路径中移除。

左叶子之和，当前节点有左节点，并且左节点是叶子节点，所以，是否为左叶子节点需要通过叶子节点的父节点来判断

从中序 + 后序 或 中序 + 前序数组构造二叉树，重点是

* 通过后序或前序确定根节点
* 拿根节点去中序数组中以根节点为分割线分割出左区间和右区间
* 再通过分割出的左区间去前序或后序数组中切割出对应的左区间
* 这时候就产生两组（左右两半）遍历数组了，递归分别处理左子树和右子树

验证二叉搜索树

* 二叉搜索树，中序遍历结果是一个生序数组，可以利用这个特性来做
* 可以直接按照中序遍历在做，也可以通过中序遍历得到数组，验证数组是否为升序数组
* 是不是也可以按照后序遍历的方式验证每个最小子树是否为二叉搜索树 ？？

验证二叉搜索树的最小绝对差，凡是在二叉搜索树上求最值，可通通看做在有序数组上完成。本题中最小差值一定在中左、中右节点之间产生。

二叉树的最近公共祖先，递归 + 回溯，通过递归（后序遍历）找到目标节点，在回溯阶段处理结果

* 如果左右不为空，那当前节点就是最近公共节点
* 如果左为空，右不为空，右节点为最近公共祖先
* 如果右为空，左不为空，左节点为最近公共组件

二叉搜索树的中的插入操作，要求插入新值后，二叉树仍然为二叉搜索树，只要遍历二叉树，将新值找到合适的空位置，直接添加上即可，树中的其它节点不需要动。

删除二叉搜索树中的节点，本质是删除后需要保证二叉搜索树的有序性

* 删除的节点为叶子节点，直接删除即可
* 删除的节点只有一个子节点（左子节点或右子节点），删除后，子节点直接补位即可
* 删除的节点有两个子节点，这是最复杂的情况（下面这种处理方式最简单了）
  * 将删除节点的左子节点添加到右子节点最左下角，然后右子节点补位即可。【本质是因为右子节点补位，左子节点添加到书中仍然需要保持树的有序性，那就只能将左子树放到右子树的左下角（左子树中节点的值本来就比右子树中节点的值小，所以要放到最小的位置）】

修建二叉搜索树，删除不符合区间的节点。利用二叉树搜索树的特性，删除不符合区间要求的子树，由符合要求的另一半子树或空节点补位。

有序数组转换为平衡二叉搜索树，窍门点在找数组的分割点，这个分割点就是根节点，分割点左边是左子树，右边是右子树，因为要平衡，所以分割点取数组中间元素。由于数组长度存在奇数、偶数情况，如果是偶数，分割点取左边、右边都行，这就导致了本题不具有唯一答案。

把二叉搜索树抓换为累加树，解题思路的灵感在于如果是一个有序数组（中序遍历的结果）该如何处理，其实就是从后往前遍历，一次累加，所以相应的就是反向中序遍历 —— 右中左。

二叉树知识图谱

* 基础的理论知识
* 二叉树的遍历方式
  * 深度，前中后序的递归、迭代遍历方式
  * 广度，利用对立的层序遍历
* 二叉树的属性，是否对称、求最大深度、求最小深度、求有多少个节点、是否平衡、找所有路径、递归中如何隐藏着回溯、求左叶子之和、求左下角的值、求路径综合
* 二叉树的修改与改造，翻转二叉树、构造二叉树、构造最大的二叉树、合并两个二叉树
* 二叉搜索树的属性，二叉搜索树中的搜索、是不是二叉搜索树搜索树、求二叉搜索树的最小绝对值、求二叉搜索树的众数、二叉搜索树转成累加树
* 二叉树公共组件问题，二叉树的公共祖先问题、二叉搜索树的公共祖先问题
* 二叉搜索树的修改与改造，二叉搜索树中的插入、删除操作、修剪二叉搜索树、构造二叉搜索树

# 回溯算法

模版，以组合问题为例子，n 个数字，找到大小为 k 的所有组合

```typescript
const result: number[] = [], path: number[] = []
function backtracking(n: number, k: number, startIndex: number) {
  if (path.length === k) {
    // 找到了符合条件的结果
    result.push([...path])
    return
  }
  // 剪枝操作，减少很多不必要的深度循环，比如 path 还需要 3个元素才能满足要求，但剩下的集合中都不足 3个元素了，就没必要往下循环递归了
  // for (let i = startIndex; i <= n - (k - path.length)； i += 1)
  for (let i = startIndex; i <= n; i += 1) {
    path.push(i)
    backtracking(n, k, i + 1)
    path.pop()
  }
}
```

回溯算法基本都是以这个为模版，根据题目要求，在加一些额外的规则，比如去重逻辑、有效性校验逻辑等。

解回溯的重点是分析阶段需要画树图，剩下的就是多练了，练多了，就发现递归和回溯似乎挺简单的。

![77.组合1](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202406151753770.png)

![77.组合4](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202406151754676.png)

![40.组合总和II1](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202406151754327.png)

# 贪心算法

贪心无套路，唯一的办法就是多见，见的题目类型多了，会的自然就多了，可能突然就悟了。



# 问题

* KMP 算法？找最长公共子串
* 实现 hashMap
* 计算器，https://leetcode.cn/problems/basic-calculator/solutions/646369/ji-ben-ji-suan-qi-by-leetcode-solution-jvir/
* 前 K 个高频元素，https://leetcode.cn/problems/top-k-frequent-elements/





