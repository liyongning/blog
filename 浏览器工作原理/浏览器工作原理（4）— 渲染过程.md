![image-20240401113410286](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404011134385.png)

每个时钟周期（一帧）的渲染流程

* 用户输入事件的响应优先级最高，如果有用户输入，浏览器进程会将该事件交给渲染进程，渲染进程的主线程优先处理该事件
* 执行 rAF 的回调
* 根据 HTML 计算 DOM Tree
* 根据 CSS 计算 CSSOM Tree，即 stylesheets 结构，进而根据 CSS 继承和层叠规则计算出每个 DOM 节点的样式
* 根据 DOM Tree 和 CSSOM Tree 计算布局树，主要是去除非视觉元素，计算每个视觉元素在页面上的位置，从而得到布局树（layout tree）
* 根据布局树计算层树（layer tree），页面会被分为很多图层，图层分配的原则是：
  * 拥有层叠上下文属性的元素，会被提升为单独的图层，比如 postion: fixed、z-index: number、filter: blur(5px)、opacity: 0.5 等，具体可[查看](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context)
  * 需要被裁剪的元素，也会被提升为单独的图层
  * 如果有滚动条，滚动条也是单独的图层
* 接下来就是绘制阶段了，即将图层树变成由一个个绘制指令组成的绘制列表，然后将绘制列表交给合成线程，以上步骤都是在渲染进程的主线程上完成的
* 合成线程接受到绘制列表后，首先是将一个个图层变成一堆图块（tile），因为图层可能会很大，但视口一般偏小，如果视口之外的元素一下全部绘制好，难免造成性能不足和资源浪费，所以浏览器将图层分割成一个个的图块，并优先绘制视口附近的图块，图块大小为 256 * 256 或 512 * 512
* 有了图块之后，接下来就是光栅化（raster）了，合成线程将具体的光栅化任务交给了光栅化线程池来完成
* 光栅化线程池维护了多个光栅化线程，图块的光栅化工作就在这鞋光栅化线程上完成
* 光栅化的过程一般都会有 GPU 的参数，用来加速渲染，所以光栅化线程会通过 IPC 通信机制将图块交给 GPU 进程，GPU 进程将这些图块绘制成位图
* 待视口附近的图块完成绘制之后，合成线程将绘制好的这些位图合成为图层，这个过程叫 layer compositor，并触发 draw quad 指令通知浏览器进程的 viz 组件进程页面绘制
* 浏览器进程的 viz 组件收到信息后，会将合成线程上合成好的图层合成渲染到显示上的图像，这个过程叫 display compositor
* 当整个过程完成之后，如果距离下一帧还有时间，即以上过程用时少于 16.6ms，渲染主线程就会进程空闲状态，这时候就会处理一些低优先级的任务，比如 requestIdleCallback 的回调、垃圾回收等

在一帧内

* 首先从任务队列取出当前要执行的任务，执行完之后并将当前任务下的所有微任务都执行完
* 判断页面是否需要渲染，这里有一个 rendering opportunity 的概念，意思是不一定每次事件循环都会伴随着渲染动作，要根据屏幕刷新率、页面性能、页面是否在后台运行来决定，页面的渲染间隔一般是是固定的 16.6ms（120HZ 则是 8.3ms），以下情况页面不会渲染
  * 页面在视觉上没有发生改变
  * 帧动画为空，即没有定义 rAF 回调
  * 如果窗口大小发生变化，但没有监听了 resize 方法
  * 页面处于非活动状态
  * 页面内存不足，页面可能会被丢弃或渲染不完整
  * 页面包含复杂或资源密集型的内容，浏览器可能无法在每帧进行渲染