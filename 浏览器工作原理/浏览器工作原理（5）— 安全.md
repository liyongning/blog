# 数组

## 二分查找

* 一定是没有重复元素的有序数组，或者可以变成没有重复元素的有序数组

* 区间问题：[left, right] 和 [left, right]

  * ```javascript
    // [left, right]
    function search(nums, target, left, right) {
      while(left <= right) {
        const middle = left + ((right - left) / 2)
        if (nums[middle] > target) {
          search(nums, target, left, middle - 1)
        }
        // ...
      }
    }
    
    // [left, right)
    function search(nums, target, left, right) {
      while(left < right) {
        const middle = left + ((right - left) / 2)
        if (nums[middle] > target) {
          // 由于 right 是开区间，所以下标为 right 的元素是不算的，如果 right = middle - 1，会漏掉一个元素
          search(nums, target, left, middle)
        }
        // ...
      }
    }
    ```

* 取中间值：`left + ((right - left) / 2)`，防止下标移除，参考下图进行演算和理解

  * |------------left-------------right|



## 移除元素

* 暴力接发 —— 双循环遍历，外层循环找到指定元素，内层循环将当前位置后面的元素往前移动，进行元素覆盖

  * 时间复杂度 O(n^2)
  * 空间负责度 O(1)

* 快慢指针，通过双指针来模拟双循环，快指针充当外层循环负责寻找指定元素，慢指针充当内存循环，如果快指针每一次移动指向的元素不是目标元素，则快慢指针移动往后移动，否则只移动快指针

  * 重要代码

    * ```javascript
      if (nums[fastIndex] !== target) {
        // 完成了元素覆盖
        nums[slowIndex++] = nums[fastIndex]
      }
      // 最后 slowIndex + 1 就是新的数组长度
      ```

  * 时间复杂度 O(n)

  * 空间复杂度 O(1)

	## 有序数组的平方

[-4,-1,0,3,10] => [16,1,0,9,100] => [0,1,9,16,100]

* 题目分析：对一个有序数据的每个元素做平方运算，需要让结果数组仍然是有序的（负数平方之后变正数，数组就不是有序的了）
* 方案：
  * 暴力解法，第一个循环遍历数组，依次对元素进行平方，然后再对平方后的数组进行排序
    * 空间复杂度 O(n)
    * 时间复杂度 O(n + nlogn)
  * 双指针，因为数组是有序的，所以平方后的最大值一定在两侧，而不是中间
    * 头指针指向数组开始位置，尾指针指向数组结束位置，每次循环移动其中一个指针，具体移动哪个取决于哪个数据平方后的结果更大
    * 额外创建一个数组，大小和原数组一致，每次都更新上一指针元素平方后更大的值所在的位置

## 长度最小的子数组

在给定数组中找到和大于等于给定值的最小连续元素，并返回元素个数

* 暴力解法，双循环，外层循环控制开始位置，内层循环从当前位置开始向后遍历元素，知道元素之和 >= 目标值，然后记录元素个数，如果在寻找过程中发现本次查找的元素个数已经大于之前的个数了，则直接结束本次查找，因为要求最小连续元素的个数
  * 空间复杂度 O(1)
  * 时间复杂度 O(n^2)
* 双指针（滑动窗口），通过双指针来模拟双循环，在两个指针之间形成一个从前向后滑动的窗口，在滑动期间窗口大小不断在变大、变小。如果当前窗口内元素之和小雨目标值，则向后移动尾指针（扩大窗口），当窗口内的元素之和 >= 目标值，开始移动头指针，直到窗口内元素之和 < 目标值，此时窗口大小 + 1 就是当前符合要求的元素个数，接着再开始移动尾指针，直到尾指针移动到结束位置并且窗口内元素之和 < 目标值，遍历结束
  * 空间复杂度 O(1)
  * 时间复杂度 O(n) => O(2n)

**滑动窗口** 的精髓之处就在于交替移动头尾指针（在从前到后移动窗口的过程中不断改变窗口大小），在不断满足目标的过程中寻找最优解

# 链表

* 单向链表、双向链表、循环链表
* 非连续存储（数据为连续存储），节点和节点之间通过 next 指针来关联
* 和数组的性能对比![img](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404072110674.png)
* 常用操作技巧
  * 设置虚拟节点来操作链表，比如移除链表元素，如果直接使用原链表操作，移除头节点时需要额外编写针对头节点的逻辑
  * 针对链表的增删改查操作，比如设计链表
  * 反转链表
    * 方案一：借助虚拟节点 + cur、pre 双指针来完成
    * 方案二：递归
  * 两两交换链表中的节点，提示：需要用到虚拟节点 + 画图（方便理解指针的移动和指向的变化）
    * ![24.两两交换链表中的节点1](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404081107586.png)
    * ![24.两两交换链表中的节点2](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404081107981.png)
    * ![24.两两交换链表中的节点3](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404081107256.png)
  * 删除链表中的倒数第 N 个节点，经典的双指针（快慢指针）应用，快指针先走 N 步，然后慢指针和快指针一起走，这样两个指针之间就形成了 N 个节点的间隔，当快指针走到链表结束后，慢指针所在的节点就是倒数第 N 个节点（这里可能会存在细节问题，实际编码的时候再修正）
  * 链表相交，双指针思路，不过这里不是快慢指针，而是用两个指针，分别走一遍两个链表，如果链表存在相交，则一定会出现 NodeA === NodeB 的情况，因为两个指针最终走的路是一样长的，如果直到两条链表都走完了，跳出了循环（null === null），则可以认为没有相交，循环的条件是 两个指针不相等
  * 环形链表，双指针解法，一个快指针一个慢指针，一旦有指针走到了结束，则说明没有环，否则一定会找到一个不为 null 的相同节点
  * 环形链表 II，双指针解法 + 数学运算，将链表分成多段，最终一定是 2(x + y) = x +(y + z) * n，最终会发现 x === z，所以就会发现两个指针分别从头和相遇点出发，再次相遇，就是入环点
    * ![img](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202404081302294.png)

# 哈希表

* 数组就是最简单的哈希表，我们可以将一些字符映射到数组下标上，比如 26个英文字母可以在数组中找到一一存放的位置。以数组作为哈希表一般都会明确限制元素个数，如果元素个数太多或者太过稀疏，则会造成空间浪费
* 哈希表最关键的设计就是哈希函数，通过哈希函数将字符映射到索引上，但经常会碰到哈希碰撞的问题，即多个字符经过哈希运算之后会映射到同一个 key 上，一般有如下两种解决方案
  * 拉链法，主要是结合链表来实现，相同 key 的 value 会通过链表来连接
  * 线性探测法，结合数组实现，如果出现 key 冲突，则 value 依次往后排
* 哈希表属于空间换时间的一种数据结构，空间复杂度 O(n)，时间复杂度 O(1)，所以需要查询或者判断元素是否存在时，可以优先考虑哈希表

这里可以深入研究的是各个语言中哈希结构的底层实现，可能会用到哈希表或红黑树，哈希结构的特点或限制就和底层的数据结构有关

## 有效的字母异位词

* 两个字符串长度必然相等
* 字符串中的字符必须一样，只是顺序不一样

借助哈希表，将 26个字符映射到数组中，依次遍历两个字符串，第一个填充，第二个删除，最后数组中元素都为 0，则说明是异位词

## 两个数组的交集

可以使用哈希表 + 加集合来完成，将其中一个数组转换成哈希表，然后遍历另外一个数组，如果发现当前元素已经在哈希表中了，说明是一个交集元素，然后将结果放到集合中，集合主要是用来做元素去重的。

## 快乐数

将给定整数的每个位置上的数字平方然后求和，循环往复，如果中间出现和重复的情况，则表示这个整数不是快乐树，如果最终得到和位 1 的情况，则认为该整数是快乐数。这里关键的有以下两点：

* 判断和是否重复，需要用到哈希表，比如集合
* 计算一个整数每一位上的数字，比如 19 => 1 和 9 => 1* 1 + 9 * 9 => 82 => 8 和 2 => ...
  * 计算可以将数字专字符串然后遍历每一位
  * 也可以通过取于 + 整除得到每一位的数字

## 两数之和

关键思路：哈希表 + 查询哈希表中是否存在 target - currentEl 的值，如果存在则直接返回结果，如果不存在则将当前元素放入哈希表，key 位元素，value 为元素在数组中的下标

## N 数之和

以后补充，当前教程的思路不是很好

## 四数相加 II

给定四个数组，然后从四个数组中各取一个元素，看有多少组和为 0 的元素，主要用到了哈希表，思路如下：

* 设置一个哈希表，用来记录 A数组 + B 数组的和，和 C 数组 + D 数组元素的和，key 为和，value 这样的和出现的次数
* 通过双循环遍历 A 和 B 数组，计算两两元素之和，并将数据填充进哈希表
* 然后通过另一个双循环，计算 C 和 D 数组中两两元素之和（F），如果发现 0 - F 在哈希表中存在，则记录 map[0 - F] 的值，否则

