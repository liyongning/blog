# 数组

## 二分查找

* 一定是没有重复元素的有序数组，或者可以变成没有重复元素的有序数组

* 区间问题：[left, right] 和 [left, right]

  * ```javascript
    // [left, right]
    function search(nums, target, left, right) {
      while(left <= right) {
        const middle = left + ((right - left) / 2)
        if (nums[middle] > target) {
          search(nums, target, left, middle - 1)
        }
        // ...
      }
    }
    
    // [left, right)
    function search(nums, target, left, right) {
      while(left < right) {
        const middle = left + ((right - left) / 2)
        if (nums[middle] > target) {
          // 由于 right 是开区间，所以下标为 right 的元素是不算的，如果 right = middle - 1，会漏掉一个元素
          search(nums, target, left, middle)
        }
        // ...
      }
    }
    ```

* 取中间值：`left + ((right - left) / 2)`，防止下标移除，参考下图进行演算和理解

  * |------------left-------------right|



## 移除元素

* 暴力接发 —— 双循环遍历，外层循环找到指定元素，内层循环将当前位置后面的元素往前移动，进行元素覆盖

  * 时间复杂度 O(n^2)
  * 空间负责度 O(1)

* 快慢指针，通过双指针来模拟双循环，快指针充当外层循环负责寻找指定元素，慢指针充当内存循环，如果快指针每一次移动指向的元素不是目标元素，则快慢指针移动往后移动，否则只移动快指针

  * 重要代码

    * ```javascript
      if (nums[fastIndex] !== target) {
        // 完成了元素覆盖
        nums[slowIndex++] = nums[fastIndex]
      }
      // 最后 slowIndex + 1 就是新的数组长度
      ```

  * 时间复杂度 O(n)

  * 空间复杂度 O(1)

	## 有序数组的平方

[-4,-1,0,3,10] => [16,1,0,9,100] => [0,1,9,16,100]

* 题目分析：对一个有序数据的每个元素做平方运算，需要让结果数组仍然是有序的（负数平方之后变正数，数组就不是有序的了）
* 方案：
  * 暴力解法，第一个循环遍历数组，依次对元素进行平方，然后再对平方后的数组进行排序
    * 空间复杂度 O(n)
    * 时间复杂度 O(n + nlogn)
  * 双指针，因为数组是有序的，所以平方后的最大值一定在两侧，而不是中间
    * 头指针指向数组开始位置，尾指针指向数组结束位置，每次循环移动其中一个指针，具体移动哪个取决于哪个数据平方后的结果更大
    * 额外创建一个数组，大小和原数组一致，每次都更新上一指针元素平方后更大的值所在的位置

## 长度最小的子数组

在给定数组中找到和大于等于给定值的最小连续元素，并返回元素个数

* 暴力解法，双循环，外层循环控制开始位置，内层循环从当前位置开始向后遍历元素，知道元素之和 >= 目标值，然后记录元素个数，如果在寻找过程中发现本次查找的元素个数已经大于之前的个数了，则直接结束本次查找，因为要求最小连续元素的个数
  * 空间复杂度 O(1)
  * 时间复杂度 O(n^2)
* 双指针（滑动窗口），通过双指针来模拟双循环，在两个指针之间形成一个从前向后滑动的窗口，在滑动期间窗口大小不断在变大、变小。如果当前窗口内元素之和小雨目标值，则向后移动尾指针（扩大窗口），当窗口内的元素之和 >= 目标值，开始移动头指针，直到窗口内元素之和 < 目标值，此时窗口大小 + 1 就是当前符合要求的元素个数，接着再开始移动尾指针，直到尾指针移动到结束位置并且窗口内元素之和 < 目标值，遍历结束
  * 空间复杂度 O(1)
  * 时间复杂度 O(n) => O(2n)

**滑动窗口** 的精髓之处就在于交替移动头尾指针（在从前到后移动窗口的过程中不断改变窗口大小），在不断满足目标的过程中寻找最优解

