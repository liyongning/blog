# 浏览器安全

浏览器安全可以分为三大块：Web 页面安全、网络安全、系统安全。

Web 是一个开放、自由的世界，任何资源都能接入其中，比如我们自己的页面、别人的网站、音频、视频等，但绝对的自由意味着无序或混沌的局面，如果页面中的行为没有任何限制，会出现很多的不可控。比如：

* 我登录了一个邮件系统 A，查看了邮件信息
* 有一天访问了一个第三方页面，这个页面内嵌了邮件系统 A，当打开后会自动请求邮件系统的邮件转发设置接口
* 这时候就会发现，我的所有邮件都会被转发到一个第三方邮箱中了

所以，在一个没有任何安全保障的 Web 世界中，我们是没有隐私的，因此我们需要一些安全策略来保证我们的隐私和数据安全。

最核心的安全策略就是：同源策略，协议、域名和端口都相同的域名为同域，同源策略主要表现在 DOM、Web 数据和网络这三个层面。

* DOM 层面，同源策略规定，同域的站点可以相互操作 DOM，但跨域的站点禁止操作对方的 DOM
* Web 数据层面，同源策略规定，禁止页面跨域操作对方的 Cookie、indexDB、storage 等
* 网络层面，同源策略规定，禁止通过 XMLHttpRequest、fetch 等 API 请求其他域名的接口

有了同源策略之后，安全性是得到了保障，但同时也带来了诸多不便，所以我们需要在安全性和便利性之间进行权衡，有时候为了灵活性，需要安全做出一些让步，让步就意味着风险，比如最常见的 XSS 攻击、CSRF 攻击。

* 页面可以嵌入第三方资源，比如我们常用的 CDN、通过 iframe 引用第三方站点。风险点是：我们没办法确认 CDN 上的脚本是否安全，比如会不会有一段恶意的 JS 脚本来获取用户数据，这就是典型的 CSS 攻击了，我们可以引入内容安全策略 —— CSP，来限制第三方资源的加载和行为
* 跨域资源共享，前端可能和服务端是两个独立的域名，同源策略会阻止向跨域的服务发送请求，这极大的制约了我们的生产力，所以引入了跨域资源共享，通过设置服务响应头，来允许跨域请求。
* 跨文档通信，跨域禁止 DOM 操作，但有时我们又需要这样的能力，于是提供了 window.postMessage 接口进行跨文档通信，从而实现跨域 DOM 操作。

# XSS 和 CSRF

XSS 攻击类型：

* 存储型
* 反射型
* 基于 DOM 的 XSS 攻击

通过对 cookie 设置 httpOnly 来保护 cookie 的安全

CSRF 攻击，利用用户的登录态啦实施攻击，比如 img 元素的 get 请求、form 表单的 post 请求、a 标签超链接的 get 请求等，开头提到的邮件系统示例也是。

* 我们可以通过 cookie 的 SameSite 来属性来保护 cookie，比如
  * Strict，禁止向第三方域名发送 cookie
  * Lax 相对宽松一点，允许在第三方连接和 get 请求的 form 表单中携带 cookie，但 post 请求、iframe、img 标签加载的 URL 则禁止携带 cookie
  * None 则表示任何情况都允许发送 cookie，但要求必须是 https 协议。
* Server 验证 referer 和 origin，有时我们不希望将 referer 暴露给 server，所以 server 结合 origin 来验证。referer 和 origin 的区别在于 referer 会携带完整的路径，但 origin 只会携带协议、域名和端口号
* 另外就是 CSRF Token，请求之前向 server 获取 CSRF Token 并保存到页面上，一般是表单中，然后请求时携带该参数，如果是通过第三方页面请求，则不会携带该参数

# 系统安全

通过沙箱包裹渲染进程来系统安全，渲染进程负责页面解析、JS 执行、页面绘制，这些第三方资源没办法保证绝对安全，所以通过沙箱来限制渲染进程的权限，所有的读写操作都需要通过 IPC 通信机制，借助浏览器的其他进程来完成，比如网络资源加载、用户操作等，这样即使页面资源有漏洞、渲染进程有漏洞，黑客的攻击行为也都被限制在了沙箱内部，无法对操作系统产生影响。这也是浏览器设计多进程架构的原因之一。

# 数据安全

https 协议让数据传输更安全。





