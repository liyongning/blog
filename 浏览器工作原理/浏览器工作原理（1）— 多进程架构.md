**当学习成为了习惯，知识也就变成了常识。** 感谢各位的 **关注**、**点赞**、**收藏**和**评论**。

新视频和文章会第一时间在微信公众号发送，欢迎关注：[李永宁lyn](https://gitee.com/liyongning/typora-image-bed/raw/master/202202171742614.jpg)

文章已收录到 [github 仓库 liyongning/blog](https://github.com/liyongning/blog)，欢迎 Watch 和 Star。

# 序

作为一名前端开发人员，我们要有一种认知：浏览器是未来。去操作系统和云化是两个大的方向，当它们达成目标时，浏览器将成为与用户接触的唯一渠道。研究浏览器，其本质就时研究交互和表现，这是前端的“终极私活”，因此无论是想设计高性能的 Web 应用，还是要优化现有的 Web 应用，我们都需要了解浏览器的工作原理，比如网络请求、页面渲染、JavaScript 执行流程，甚至是一些安全方面的理论知识，因此，了解浏览器是必要的。

但市面上对于浏览器的介绍一直都是零零散散的知识，自己也是一直希望能够深入了解浏览器，因此就有了本专栏。

专栏中所有的分析都是基于 Chrome 浏览器的，因为 Chrome、Edge 和国内大部分主流浏览器都是基于 Chromium 二次开发而来，而 Chrome 是 Google 的官方发行版，特性和 Chromium 基本一样，只存在一些产品层面的差异；再加上 Chrome 是目前世界上使用率最高的浏览器，所以 Chrome 最具代表性。

> 根据市场调查机构 Statcounter 公布的最新报告，2024年2月份 Chrome 浏览器以 65.38% 的市场份额稳居全球浏览器份额第一，苹果的 Safari 浏览器以 18.31% 位居第二，微软 Edge 则以 5.07% 位居第三，可以发现 Chrome 的份额遥遥领先。在互联网 IT 从业者中，Chrome 浏览器的所占份额想必会更夸张，毕竟专业的程序员都用 Chrome。

我们以一个问题作为本系列的开始：**Chrome 打开一个页面需要启动多少个进程**？以[我的 Github 博客首页](https://github.com/liyongning/blog)为例，如图所示：

![image-20240319123310399](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202403191233512.png)

任务管理器可通过右上角的 `三个点(选项菜单)` -> 更多工具 -> 任务管理器 来打开。通过任务管理器我们发现一个页面打开了 6个进程。第一感觉：这有点夸张，我只是在浏览器中打开了一个页面而已，怎么产生了这么多进程？带着问题继续往下看。

# 浏览器的发展

浏览器架构的发展大概有这么几个关键阶段：**单进程浏览器**、**多进程浏览器**、**沙箱技术的应用**、**WebAssembly** 技术的兴起。多进程浏览器 + 沙箱技术的应用解决了单进程浏览器时代的稳定性、安全性和性能问题。而 WebAssembly 技术的出现，则是为前端带来了太多新的可能性。

## 单进程浏览器

![image-20240317134930669](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202403171349738.png)

最早期的浏览器都是单进程架构，顾名思义，我们在浏览器看到的所有模块（比如工具栏、页面、插件、网络请求、JS 等）都运行在一个进程中。这些功能模块或通过进程来执行，或以线程的方式来运行，这就导致了如下问题

### 不稳定

一个进程中运行了如此多的线程，任何一个线程崩溃都可能会导致整个进程崩溃，会想一下早先年我们是不是经常碰到如下场景：

**插件导致浏览器崩溃**：我们在浏览器中安装了一个稳定性较差的插件，或者早先年我们需要借助插件来实现 Web 视频播放或游戏等强大功能，但插件是最容易出现问题的模块，插件模块是作为一个线程运行在浏览器进程中的，一旦插件出现问题，就可能会导致整个浏览器崩溃。

**渲染线程导致浏览器崩溃**：渲染线程负责执行用户代码完成页面渲染，如果某段用户代码出现异常，比如无限循环或复杂的 JS 代码，导致线程卡死，就会出现所有页面卡死，甚至浏览器崩溃的场景，而且那么多页面运行在一个线程中，没人能保证打开的页面都是稳定的。

### 不安全

页面脚本可以通过浏览器漏洞来获取系统权限，从而直接操作你的电脑，对电脑做一些恶意的事情。

插件可以使用 C 或 C++ 来编写，通过插件可以获取到系统的任意资源，这就意味着，页面上运行的插件可以操作你的电脑，从而释放一些病毒文件、执行一些病毒程序等，从而导致电脑出现安全问题。

### 不流畅

一个浏览器，只有一个进程，一个进程下只有一个渲染线程，浏览器中打开的所有页面都运行在这一个线程上。如果某个页面有一段这样的 JS 代码：

```javascript
function loop() {
  console.log('loop function running')
  loop();
}
loop();
```

这是一段循环调用的代码，执行后会出现什么样的报错，大家都很清楚。但在单进程架构的浏览器下，这样一段代码带来的问题就很严重了：这段代码一旦开始执行后，它就会一直占用线程，直到爆栈，在这期间，其他页面一直无法得到响应（因为线程被当前代码占用），就会出现假死甚至真卡死的情况，直到爆栈导致线程崩溃，从而导致整个浏览器崩溃。

以上三个现象，在早期的浏览器中，相信大家经常会遇到，特别是在浏览器中给老板写邮件期间，打开了某个页面，查询个什么信息，出现了上述三种情况，直接崩溃。。

------

读到这里，相信可能会有人有这样一个疑问：**单进程浏览器开多个页面，渲染线程只有一个吗？一个页面配一个渲染线程不是更合理吗**？

这个问题需要从 IE6 讲起，IE6 浏览器是单进程的，一个窗口配一个标签页。当时国产浏览器基于 IE6 二次开发，但它们需要一个窗口配多个标签页，这就意味着所有页面都共享同一套 JS 运行环境，所以一个标签页的卡顿会影响整个浏览器。

所以国产浏览器开始尝试支持页面多线程，也就是让每个页面运行在单独的线程中，意味着每个线程拥有单独的 JS 执行环境和 Cookie 环境，但这时候发现个问题，比如：A 站点登录了一个网站，保存了一些 Cookie 到磁盘上，并且在当前线程中保存了一些 Session 数据，但由于 Seesion 不存盘，所以 Session 只会存在当前的线程环境中，这时候在另外一个 Tab 页打开 A 站点，就会发现获取不到 Session 数据。所以，需要实现一个 Session 同步能力，但由于 IE 并没有暴露源码，所以实现起来非常困难，国内花了很长时间才解决这个问题。

Session 问题虽然解决了，但页面假死问题依然存在，因为进程内使用了一个窗口，这个窗口依附到浏览器主窗口之上，所以它们共用一套消息循环机制，这就意味着如果一个窗口卡死，也会导致整个浏览器卡死。于是国产浏览器就把页面做成一个单独的窗口，如果这个页面卡死了，就把这个窗口隐藏掉。但 Chrome 为什么不会出现页面假死影响到主窗口的问题呢？这是因为 Chrome 输出的内容是图像，浏览器把图像贴到自己的窗口上，在 Chrome 的渲染进程内，并没有一个渲染窗口，输出的只有图像，如果卡住了，最多图像不更新。

国产浏览器这套技术花了四五年时间，等整套技术差不多成熟时，Chrome 发布了......

## 早期的多进程架构

![image-20240316081729219](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202403160817339.png)

2008 年，Chrome 多进程架构发布了，可以看到页面渲染和插件从主进程中独立出来了，每个页面运行在独立的渲染进程中，插件则运行在插件进程中，进程之间通过 IPC 机制进行通信。现在再来看看多进程架构是如何解决单进程架构的问题的。

### 不稳定

**进程之间是相互隔离的**，所以个别插件和页面的崩溃只会影响各自的插件进程和渲染进程，而不会影响到其他插件进程和渲染进程，更不会影响到浏览器主进程。

### 不安全

安全性问题是通过**沙箱**来解决。可以看到在渲染进程和插件进程外面套了一层沙箱，通过沙箱来限制渲染进程的操作权限，比如禁止对磁盘进行读写，和系统的交互都是借助主进程来完成的。沙箱的应用是得益于多进程架构，因为在单进程中不能直接给整个浏览器套一层沙箱，浏览器主进程的权限相对来说还是比较高的（非 root 权限）。

### 不流畅

还是**进程之间是相互隔离的**，JS 执行、页面渲染影响的只有当前渲染进程，而不会影响到其他页面所在的渲染进程。另外，内存是在进程中管理的，即使出现内存泄漏，把当前页面关了，渲染进程也就被释放了，内存泄漏的问题自然也就没了。

## 当前的多进程架构

![image-20240316081802366](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202403160818393.png)

Chrome 浏览器的迭代从未停止，可以看到进程分离做的越来越极致，相比于最初的多进程架构，现在将网络进程和 GPU 进程也从主进程中独立出来了。所以目前，浏览器的包括：一个主进程、一个网络进程、一个 GPU 进程、多个插件进程和多个渲染进程。

**主进程**：负责浏览器主框架（浏览器窗口、地址栏、书签栏等非用户界面）的管理、用户交互、子进程管理、存储管理、系统交互等。

**网络进程**：负责浏览器中所有网络资源的加载。

**GPU 进程**：早期是为了满足 CSS 3D 渲染的需求，但后来 UI 页面也采用 GPU 来绘制，所以 GPU 就成为了浏览器的普遍需求。

**插件进程**：负责运行插件，插件易崩溃，所以将插件隔离在独立的进程内，即使崩溃也不会影响到浏览器和用户页面。

**渲染进程**：负责将 HTML、CSS、JS 转换为用户可以与之交互的界面。排版引擎 Blink 和 JS 引擎 V8 都运行在该进程下。浏览器会为每个 Tab 页创建一个渲染进程，处于安全考虑，每个渲染进程都运行在沙箱里。

### 多进程架构的缺陷

凡事都有利弊，多进程架构虽然提升了浏览器的稳定性、安全性和流畅性，但也带来了一些额外的问题：

**更高的资源占用**，每个进程都包含了一些公共基础模块，这就意味着浏览器会消耗更多的内存资源。

**更复杂的架构设计**，浏览器各模块之间耦合性高、扩展性差，导致现在的架构已经很难适应新的需求了。

## 模块服务化

针对现有问题，Chrome 团队使用**面向服务的架构**思想设计了新的 Chrome 架构，一句话简单总结就是：代码重构、拆分，让代码组织更合理，一些基础能力以服务的形式对外提供，而不再耦合在进程中。到目前为止有些能力已经发布了，但有些模块还在持续开发中，这是一项任重而道远的工作。

另外，Chrome 提供了一种弹性架构，当性能强大的宿主机上会以多进程的模式进程，但在资源受限的机器上，则会将部分服务整个到一个进程中，从而节省资源。

# 进程计算

看完 Chrome 整个架构发展的历程，现在我们再回头看开头提到的那个问题：**Chrome 打开一个页面需要启动多少个进程**？以[我的 Github 博客首页](https://github.com/liyongning/blog)为例。

直接回答应该是：一个浏览器进程、一个 GPU 进程、一个网络进程、一个渲染进程，所以 Chrome 打开一个页面至少需要启动 4个进程。

实际答案如图所示：

![](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202403191233815.png)

会发现有些和预期不一样的地方：

* **网络服务**：不是预期中的网络进程，这个就是 Chrome 最新的**面向服务的架构**，将一些基础的公共能力以服务的形式对外提供，比如图中所示的网络服务和存储服务。
* **存储服务**：是因为当前页面用了浏览器的存储，比如 localStorage 和 sessionStorage
* **备用渲染程序**：在主渲染进程发生故障时，Chrome 会尝试重启该进程或启动一个备用渲染程序，以保持用户当前打开页面的稳定性和可用性，这样可以避免页面崩溃或者导致用户数据丢失的情况发生

读到这里，是否有这样一个疑问：**如何计算 Chrome 中渲染进程的个数**？

## 如何计算 Chrome 中渲染进程的个数

### 正常情况，一个页面至少需要一个渲染进程

比如有如下代码，打开后只有一个渲染进程

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>主页面</title>
</head>
<body>
  <div>
    主页面
  </div>
</body>
</html>
```

![image-20240318202957241](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202403182029394.png)

基于这个正常情况下的结论我们再来看特殊情况

### 浏览上下文组中同一站点的页面共用一个渲染进程

比如，对主页面进行简单的改动，通过 window.open 打开同站点的另一个页面，如下代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>主页面</title>
</head>
<body>
  <div>
    主页面
  </div>
  <!-- 通过 a 标签在当前页中打开同站点的页面，不会创建新的渲染进程 -->
  <div>
    <a href="http://page2.360.cn:3000/page2.html" target="_self">page2</a>
  </div>
  <!-- window.open 打开同站点页面，不会创建新的渲染进程 -->
  <div>
    <button id="page2">page2</button>
  </div>
  <!-- 通过 iframe 打开同站点页面，会创建新的渲染进程 -->
  <iframe src="http://page2.360.cn:3000/page2.html"></iframe>
  <script>
    document.querySelector('#page2').addEventListener('click', () => {
      window.open('http://page2.360.cn:3000/page2.html')
    })
  </script>
</body>
</html>
```

发现 page2 并没有新开渲染进程，而是和主页面共用一个渲染进程

![image-20240319095640064](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202403190956127.png)

#### 浏览上下文组

我们把一个标签页所包含的内容，比如 window 对象、历史记录、滚动条位置等信息称为浏览上下文，而通过脚本相互连接的浏览上下文就是**浏览上下文组**。一般通过以下方式打开的页面或弹窗和父页面同属一个上下文组：

* 通过`window.open`方法打开页面
* 通过 a 标签在当前标签页打开一个同站点的页面
* form 表单提交后的结果页在当前页打开
* alert、confirm、promt 打开的弹窗
* 当前页中内嵌的 iframe 页面，和父页面同属一个浏览上下文组

如果不想让 window.open 和 a 标签打开的页面和父页面产生关联，可以使用 **noopener**、**noreferrer** 属性，意思是让新页面的 window.opener 为 null 并且和父页面不产生关联，这时候会发现两个页面各占一个渲染进程。 

```javascript
// 可以通过 newWindow 来操作新页面，但会受跨域的限制
const newWindow = window.open('xxx')
```

#### 什么是跨站、跨域

* **是否跨站**：当协议和二级域名相同，即为同站，否则为跨站。

> 以 https://baidu.com 为例，https 为协议，.com 为根域（顶级域名、一级域名），baidu.com 为二级域名

* **是否跨域**：当协议、域名和端口号相同，即为同域，否则为跨域。

#### 如何判断一个请求是同站、同域还是跨站？

所有的新型浏览器发送请求时，都会携带 **Sec-Fetch-Site** HTTP 标头，标头的值为：cross-site、same-site、same-origin、none。

通过检查 Sec-Fetch-Site 的值，可以确定请求是 same-site、same-origin 还是 cross-site，比如：

* 同站，都是 https + 360.cn

![image-20240319102117575](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202403191021684.png)

* 跨站，二级域名不同，一个是 360.cn，一个是 qihoo.net

![image-20240319102351853](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202403191023893.png)

* 同域，协议、域名、端口号一样，都是 https://sentry.esc.360.cn，端口号为默认端口 —— 443

![image-20240319102745924](https://raw.githubusercontent.com/liyongning/picture-bed/master/liyongning/202403191027959.png)

你可以合理信任 Sec-Fetch-Site 标头的值，原因如下：

* JavaScript 无法修改以 Sec- 开头的 HTTP 标头
* 这些标头使用由浏览器设置

即使服务器收到了被客户端篡改的 Sec-Fetch-Site 标头，页不会因违反同源策略而对用户或浏览器造成危害。

## Chrome 打开一个页面需要启动多少个进程？

到这里，我们就可以完整的回答文章开头提到的问题了：

* 首先，打开一个面至少需要启动 4个进程，分别是一个浏览器进程、一个网络进程（服务）、一个 GPU 进程、一个渲染进程。

* 如果页面中使用了浏览器存储，还会再打开一个存储进程（服务）。

* 如果页面运行了 x 个插件，则还会有 x 个插件进程。

* 如果页面中内嵌了 x 个跨站的页面，则会额外再启动 x 个渲染进程。

# 总结

到这里，本文就结束了，作为本系列的开篇，文章主要讲解了如下内容：

* 开头，讲了为什么会有本系列。一是为什么要深入了解浏览器？二是浏览器方面的知识都是零零散散的，三是本系列也相当于自己学习的一个记录（笔记）
* 第二部分讲了浏览器的四个发展阶段，从单进程架构 -> 早期多进程架构 -> 成熟的多进程架构 -> 多进程架构 + 模块服务化。每一次迭代都是为了解决特定的问题，让用户体验更好
* 基于问题 —— **Chrome 打开一个页面需要启动多少个进程**，讲了如何计算浏览器中的进程数。顺带讲了浏览上下文组、跨站、跨域的相关概念

宏观层面的浏览器架构相关知识到这里就结束了，但后面的页面**导航过程**和**渲染过程**会有更细节的讲解，下篇我们将讲解**浏览器中的网络知识**。

---

**当学习成为了习惯，知识也就变成了常识。** 感谢各位的 **关注**、**点赞**、**收藏**和**评论**。

新视频和文章会第一时间在微信公众号发送，欢迎关注：[李永宁lyn](https://gitee.com/liyongning/typora-image-bed/raw/master/202202171742614.jpg)

文章已收录到 [github 仓库 liyongning/blog](https://github.com/liyongning/blog)，欢迎 Watch 和 Star。
